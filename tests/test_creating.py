# -*- encoding: utf-8 -*-
# test_creating.py - unit tests for creating resources
#
# Copyright 2011 Lincoln de Sousa <lincoln@comum.org>.
# Copyright 2012, 2013, 2014, 2015, 2016 Jeffrey Finkelstein
#           <jeffrey.finkelstein@gmail.com> and contributors.
#
# This file is part of rest-utils.
#
# rest-utils is distributed under both the GNU Affero General Public
# License version 3 and under the 3-clause BSD license. For more
# information, see LICENSE.AGPL and LICENSE.BSD.
"""Unit tests for creating resources from endpoints generated by
rest-utils.

This module includes tests for additional functionality that is not
already tested by :mod:`test_jsonapi`, the package that guarantees
rest-utils meets the minimum requirements of the JSON API
specification.

"""
from __future__ import division
from datetime import datetime

import dateutil
from sqlalchemy import Column
from sqlalchemy import Date
from sqlalchemy import DateTime
from sqlalchemy import ForeignKey
from sqlalchemy import Integer
from sqlalchemy import Interval
from sqlalchemy import Time
from sqlalchemy import Unicode
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import relationship

from base import APIManager
from base import BetterJSONEncoder as JSONEncoder
from base import dumps
from base import loads
from base import FlaskSQLAlchemyTestBase
from base import MemoryManagerTestBase
from base import SqliteManagerTestBase


class TestCreating(MemoryManagerTestBase):
    """Tests for creating resources."""

    def setUp(self):
        super(TestCreating, self).setUp()

        class Article(self.Base):
            __tablename__ = 'article'
            id = Column(Integer, primary_key=True)
            date_created = Column(Date)
            author_id = Column(Integer, ForeignKey('person.id'))
            author = relationship('Person')
            type = Column(Unicode)

        class Person(self.Base):
            __tablename__ = 'person'
            id = Column(Integer, primary_key=True)
            age = Column(Integer)
            name = Column(Unicode, unique=True)
            birth_datetime = Column(DateTime, nullable=True)
            bedtime = Column(Time)
            hangtime = Column(Interval)
            articles = relationship('Article')

        class Tag(self.Base):
            __tablename__ = 'tag'
            id = Column(Integer, primary_key=True)
            name = Column(Unicode)

        self.Article = Article
        self.Person = Person
        self.Tag = Tag
        self.Base.metadata.create_all()
        self.manager.add(Person, methods=['POST'])
        self.manager.add(Article, methods=['POST'])
        self.manager.add(Tag, methods=['GET', 'POST', "PUT", "DELETE"])

    def get_response(self, uri, status_code, params=None, has_data=True,
            headers=None):
        """Return the response generated from a generic GET request. Do basic
        validation on the response."""
        if headers is None:
            headers = {}
        response = self.req.get(uri, query_string=params, headers=headers)
        assert response.status_code == status_code
        if has_data:
            assert response.data
        return response

    def post_response(self):
        """Return the response generated from a generic POST request. Do basic
        validation on the response."""
        response = self.req.post('/tag',
            headers={
                "Content-Type": 'application/json'
            },
            data=dumps({
                u'name': u'Jeff Knupp'
            }))
        assert response.status_code == 201
        assert loads(response.data)[u'name'] == u'Jeff Knupp'
        return response

    def test_post(self):
        """Test simple HTTP POST"""
        response = self.post_response()
        assert loads(response.data) == {
            'id': 1,
            'name': 'Jeff Knupp',
        }

    def test_put_new_resource(self):
        """Send HTTP PUT for a resource which doesn't exist (should be
        created)."""
        response = self.req.put('/tag/2',
            headers={
                "Content-Type": 'application/json'
            },
            data=dumps({
                u'id': 2,
                u'name': u'Jeff Knupp'
            }))
        assert response.status_code == 201
        assert loads(response.data)['name'] == u'Jeff Knupp'

    def test_put_existing_resource(self):
        """Send HTTP PUT for an existing resource (should be updated)."""
        self.post_response()
        response = self.req.put('/tag/1',
            headers={
                "Content-Type": 'application/json'
            },
            data=dumps({
                u'name': u'Jeff Knupp2'
            }))
        assert response.status_code == 200
        response = self.get_response('/tag/1', 200)
        assert loads(
            response.data)[u'name'] == u'Jeff Knupp2'
        assert loads(
            response.data)[u'id'] == 1

    def test_delete_resource(self):
        """Test DELETEing a resource."""
        self.post_response()
        response = self.req.delete('/tag/1')
        assert response.status_code == 204
        response = self.get_response('/tag/1', 404, False)

    def test_delete_non_existant_resource(self):
        """Test DELETEing a resource that doesn't exist."""
        response = self.req.delete('/tag/404')
        assert response.status_code == 404

    def test_post_muti_resource(self):
        """
        批量创建
        :return:
        """
        res = self.post('/tag', json=[
            {
                u"name": u'muti_create1'
            },
            {
                u"name": u'muti_create2'
            },
            {
                u"name": u'muti_create3'
            },
            {
                u"name": u'not_found_1'
            },
        ])
        assert res.status_code == 201
        assert len(loads(res.data)) == 4
        assert len(loads(self.req.get('/tag', query_string={
            'name': "%muti_create%",
        }).data)['items']) == 3
        assert self.session.query(self.Tag).count() == 4
        assert len(loads(self.req.get('/tag').data)['items']) == 4

    def test_post_muti_resource_error(self):
        """
        批量创建出错,存在一个相同的
        :return:
        """
        self.post_response()
        res = self.post('/tag', json=[
            {
                u"id": 1,
                u"name": u'ready exist'
            },
            {
                u"name": u'muti_create_error1'
            },
        ])
        assert self.session.query(self.Tag).filter_by(name=u'muti_create_error1').count() == 0
        assert self.session.query(self.Tag).filter_by(name=u'ready exist').count() == 0
        self.assertRestException(res, u"ResourcesAlreadyExists")

    def test_get_not_exist_path(self):
        res = self.req.get('/tag/xx/xx/xx')
        self.assertRestException(res, u"AccessDenied")

    def test_put_muti_resource(self):
        """
        批量修改
        :return:
        """
        old_res = self.post('/tag', json=[
            {
                u"name": u'muti_update1'
            },
            {
                u"name": u'muti_update2'
            },
            {
                u"name": u'muti_update3'
            },
        ])
        assert old_res.status_code == 201
        assert len(loads(old_res.data)) == 3
        old_items = loads(self.req.get('/tag', query_string={
            'name': "%muti_update%",
        }).data)['items']
        assert len(old_items) == 3
        new_items = []
        for item in old_items:
            new_dict = dict(item)
            new_dict['name'] += '_update'
            new_items.append(new_dict)
        res = self.put('/tag', json=new_items)
        assert res.status_code == 200
        assert len(loads(res.data)) == 3
        now_items = loads(self.req.get('/tag', query_string={
            'name': "%muti_update%",
        }).data)['items']
        assert now_items
        for item in now_items:
            assert item['name'].endswith('_update')

    def test_put_one_resource(self):
        """
        单个修改
        :return:
        """
        old_res = self.post('/tag', json={
            u"name": u'one_update1'
        })
        assert old_res.status_code == 201
        assert isinstance(loads(old_res.data), dict)
        old_items = loads(self.req.get('/tag', query_string={
            'name': "%one_update%",
        }).data)['items']
        assert len(old_items) == 1
        old_item = old_items[0]
        new_item = dict(old_item)
        new_item['name'] += '_update'
        res = self.put('/tag', json=new_item)
        assert res.status_code == 200
        assert isinstance(loads(res.data), dict)
        now_items = loads(self.req.get('/tag', query_string={
            'name': "%one_update%",
        }).data)['items']
        assert now_items
        for item in now_items:
            assert item['name'].endswith('_update')

    def test_post_collection_sure_id(self):
        # put json data
        res = self.req.put('/tag/99988', data={
            'name': 'Some tag',
        })
        assert res.status_code == 201
        assert self.session.query(self.Tag).filter_by(id=99988).count() == 1
        res = self.req.delete('/tag/99988')
        # put form data
        assert res.status_code == 204
        res = self.req.put('/tag/99988', data={
            'name': 'Some New tag',
        })
        assert res.status_code == 201
        assert self.session.query(self.Tag).filter_by(id=99988).first().name == 'Some New tag'
        res = self.req.delete('/tag/99988')
        assert res.status_code == 204


class TestGetting(SqliteManagerTestBase):
    def setUp(self):
        """Creates the database, the :class:`~flask.Flask` object, the
        :class:`~rest_utils.manager.APIManager` for that application, and
        creates the ReSTful API endpoints for the :class:`TestSupport.Person`
        and :class:`TestSupport.Article` models.

        """
        super(TestGetting, self).setUp()
        self.manager.add(self.Artist, alias_name="artists")
        self.manager.add(self.Track, alias_name="tracks")
        self.manager.add(self.Playlist)

    def get_response(self, uri, status_code, params=None, has_data=True,
            headers=None):
        """Return the response generated from a generic GET request. Do basic
        validation on the response."""
        if headers is None:
            headers = {}
        response = self.req.get(uri, query_string=params, headers=headers)
        assert response.status_code == status_code
        if has_data:
            assert response.data
        return response

    def test_get(self):
        """Test simple HTTP GET"""
        response = self.get_response('/artists', 200)
        assert len(loads(response.data)[u'items']) == 275
        assert loads(response.data)[u'total'] == 275

    def test_get_with_limit(self):
        """Test simple HTTP GET"""
        response = self.get_response('/artists', 200, params={
            '_num': 10
        })
        assert len(loads(response.data)[u'items']) == 10

    def test_get_with_filter(self):
        """Test simple HTTP GET"""
        response = self.get_response('/artists', 200, params={
            'Name': 'AC/DC'
        })
        assert len(loads(response.data)[u'items']) == 1

    def test_get_with_like_filter(self):
        """Test simple HTTP GET"""
        response = self.get_response('/artists', 200, params={
            'Name': '%AC%DC%'
        })
        assert len(loads(response.data)[u'items']) == 1

    def test_get_with_sort(self):
        """Test simple HTTP GET"""
        response = self.get_response('/artists', 200, params={
            '_sort': 'Name'
        })
        assert loads(response.data)[u'items'][0]['Name'] == 'A Cor Do Som'

    def test_get_object_attribute(self):
        """Test simple HTTP GET"""
        response = self.get_response('/tracks/347', 200)
        response = self.get_response('/tracks/347/Genre', 200)
        assert loads(response.data)[u'Name'] == 'Rock'

    def test_get_expanded_resource(self):
        """Does GETing a resource return the 'Link' header field?"""
        response = self.get_response('/tracks/1', 200, params={
            '_expand': 1
        })
        assert 'Album' in loads(response.data)

    def test_get_with_params_not_lazy_dynamic_still_success(self):
        res = self.get('/Playlist/13/Track', params={
            "Name": "%For%",
        })
        assert res.json()['total'] == 6

    # def test_get_etag_header(self):
    #     # TODO 实现ETAG
    #     """Does GETing a resource with the ETag header return a 304?"""
    #     response = self.get_response('/tracks/1', 200)
    #     assert 'ETag' in response.headers
    #     etag_value = response.headers['ETag']
    #     cached_response = self.get_response('/tracks/1', 304, headers={'If-None-Match': etag_value}, has_data=False)
    #
    # def test_get_etag_no_match(self):
    #     # TODO 实现ETAG
    #     """Does GETing a resource return the 'Link' header field?"""
    #     response = self.get_response('/tracks/1', 200)
    #     assert 'ETag' in response.headers
    #     cached_response = self.get_response('/tracks/1', 412, headers={'If-Match': 'foo'}, has_data=False)
